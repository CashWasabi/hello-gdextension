# Hello GDExtension
In this first interaction with the GDExtension API, we'll create a simple "Hello World" extension that prints a static message when it gets loaded.

To get to know GDExtension in more depth, we'll be using the raw API in plain C.
In a later sample we'll use C++ with the [godot-cpp](https://github.com/godotengine/godot-cpp) bindings, which should provide much better usability.


## Generating GDExtension API files
First thing we need to do is either download or generate the `gdextension_interface.h` and `extension_api.json` files.
The `gdextension_interface.h` contains the GDExtension API definitions, while `extension_api.json` is a huge JSON file containing metadata about all Godot classes, utility functions and enumerations.

At the time of writing, the [godot-headers](https://github.com/godotengine/godot-headers) repository has an outdated version of these files, so we'll generate them using the Godot editor.

To keep things organized, let's first create a new folder for them called `include`:

```sh
mkdir include
```

Assuming Godot 4 is available in your system's `PATH` as `godot`, run the following inside our newly created `include` directory:

```sh
godot --dump-extension-api --dump-gdextension-interface --headless
```

Using `--dump-extension-api` asks Godot to generate the `extension_api.json` file.
Using `--dump-gdextension-interface` asks Godot to generate the `gdextension_interface.h` file.
Using `--headless` makes Godot use the dummy display and audio drivers, speeding the whole process up.

In the end, our directory should be something like this:

```
.
└─ include/
   ├─ extension_api.json
   └─ gdextension_interface.h
```


## Creating an empty library
Ok, now that we have the API available, we can start creating our extension.

Let's start by creating a C file named `hello-gdextension.c`.
We'll include the `gdextension_interface.h` file and define a function that will be the entry point to our library, the one that Godot will call when loading our extension.
This entry point must follow the `GDExtensionInitializationFunction` prototype, defined in `gdextension_interface.h`.

```c
// hello-gdextension.c

// 1. Include the GDExtension API file
#include "include/gdextension_interface.h"

// 2. Define the function with prototype matching GDExtensionInitializationFunction
GDExtensionBool hello_extension_entry(
    const GDExtensionInterface *p_interface,
    GDExtensionClassLibraryPtr p_library,
    GDExtensionInitialization *r_initialization
) {
    // returning 0 means error, returning non-zero means success
    return 1;
}
```

Now that we have our C file, we need to compile it to a shared library, a.k.a. DLL.
This project is so simple, with a single source file, that we could run the C compiler directly.
But to simplify our lives and prepare ourselves to handle more complex projects in the future, let's use a build system.

We can use any one of them.
There are lots of good ones, like [Make](https://www.gnu.org/software/make/), [CMake](https://cmake.org/), [Meson](https://mesonbuild.com/), [SCons](https://scons.org/), [xmake](https://xmake.io), [Bazel](https://bazel.build/)...
For this tutorial, we'll be using [SCons](https://scons.org/), which is the same one that Godot and godot-cpp use.

After installing SCons, create a file named `SConstruct` with the following contents:

```python
SharedLibrary('hello-gdextension.c')
```

Now running the `scons` command should build our shared library correctly, independent of the platform we are running and which C compiler is installed:

```sh
scons
# scons: Reading SConscript files ...
# scons: done reading SConscript files.
# scons: Building targets ...
# gcc -o hello-gdextension.os -c -fPIC hello-gdextension.c
# gcc -o libhello-gdextension.so -shared hello-gdextension.os
# scons: done building targets.
```

Ignoring the files generated by `scons`, our current directory should look like this:

```
.
├─ hello-gdextension.c
├─ include/
│  ├─ extension_api.json
│  └─ gdextension_interface.h
└─ SConstruct
```


## Configuring the extension
As well as the shared libraries containing the built code, extensions are composed by an INI-formatted file with extension `.gdextension` that contains a symbol to the entry point function and the library paths, one for each platform/CPU architecture.

Let's define our own `hello.gdextension` file:

```ini
[configuration]
entry_symbol = "hello_extension_entry"

[libraries]
linux.x86_64 = "libhello-gdextensions.so"
windows.x86_64 = "hello-gdextensions.dll"
macos = "libhello-gdextensions.dylib"
```

If we eventually add support for other platforms, like Android or iOS, or CPU architectures, like `x86` or `arm64`, we need to add more entries to this file.

Also notice that, in Linux and macOS, `scons` generates libraries with `lib` prefixed in their name.

All right, now when we run Godot 4 with our built extension, it should be correctly loaded.
I've added a sample project file with an empty scene in the root of this repository, but you can also create your own to test this out.

```sh
godot --upwards --headless --quit
# ERROR: Condition "initialization.initialize == nullptr" is true.
#    at: initialize_library (core/extension/gdextension.cpp:447)
# Godot Engine v4.0.beta10.official.d0398f62f - https://godotengine.org
# ...
# ================================================================
# handle_crash: Program crashed with signal 11
# Engine version: Godot Engine v4.0.beta10.official (d0398f62f08ce0cfba80990b21c6af4181f93fe9)
# Dumping the backtrace. Please include this when reporting the bug on: https://github.com/godotengine/godot/issues
# [1] /usr/lib/libc.so.6 ...
# -- END OF BACKTRACE --
# ================================================================
```

I didn't promise the editor wouldn't crash, only that our library would be loaded.
Our extension still needs to define the `initialization.initialize` and `deinitialize` functions.

Current directory:

```
.
├─ hello.gdextension
├─ hello-gdextension.c
├─ include/
│  ├─ extension_api.json
│  └─ gdextension_interface.h
└─ SConstruct
```


## GDExtension life cycle
While Godot is initializing, it also initializes all GDExtensions by calling the `initialize` function in the `GDExtensionInitialization` pointer that was passed to our entry point.
While quitting, Godot deinitializes all extensions by calling the `deinitialize` function.

As extension developers, we are responsible for implementing both functions and setting them up in the initialization structure.
Open up `hello-gdextension.c` and create both functions.
To help us understanding that our library is running, let's also add some debug logs.

```c
// `printf` is part of the `stdio.h` header
#include <stdio.h>
#include "include/gdextension_interface.h"

void initialize(void *userdata, GDExtensionInitializationLevel p_level) {
    printf("initialize at level %d\n", p_level);
}

void deinitialize(void *userdata, GDExtensionInitializationLevel p_level) {
    printf("deinitialize at level %d\n", p_level);
}

GDExtensionBool hello_extension_entry(
    const GDExtensionInterface *p_interface,
    GDExtensionClassLibraryPtr p_library,
    GDExtensionInitialization *r_initialization
) {
    // setup the `initialize` function
    r_initialization->initialize = &initialize;
    // setup the `deinitialize` function
    r_initialization->deinitialize = &deinitialize;
    return 1;
}
```

Recompile using `scons`, run Godot again and check out the output:

```sh
godot --upwards --headless --quit
# initialize at level 0
# Godot Engine v4.0.beta10.official.d0398f62f - https://godotengine.org
# initialize at level 1
# 
# initialize at level 2
# initialize at level 3
# deinitialize at level 3
# deinitialize at level 2
# deinitialize at level 1
# deinitialize at level 0
```

As we can see, Godot initializes and deinitializes our extension 4 times, one for each initialization level.
The `GDExtensionInitializationLevel` enumeration lists the possible initialization levels Godot use:

- `GDEXTENSION_INITIALIZATION_CORE`: happens right after the engine's core modules are initialized.
- `GDEXTENSION_INITIALIZATION_SERVERS`: happens right after the engine's servers are initialized.
- `GDEXTENSION_INITIALIZATION_SCENE`: happens right after the engine's runtime classes are registered.
    Only then classes, including core ones like `Object`, `Reference` and `Node`, are in the ClassDB and may be extended.
- `GDEXTENSION_INITIALIZATION_EDITOR`: happens only in the editor, right after editor classes are registered, like `EditorPlugin`.
  Use this for editor-only code in extensions.

We are responsible for checking the right initialization level and only run our code when appropriate.
We can use conditional statements for that:

```c
#include <stdio.h>
#include "include/gdextension_interface.h"

void initialize(void *userdata, GDExtensionInitializationLevel p_level) {
    // return early without printing if initialization level is not "Scene"
    if (p_level != GDEXTENSION_INITIALIZATION_SCENE) {
        return;
    }

    printf("initialize at level %d\n", p_level);
}

void deinitialize(void *userdata, GDExtensionInitializationLevel p_level) {
    // return early without printing if initialization level is not "Scene"
    if (p_level != GDEXTENSION_INITIALIZATION_SCENE) {
        return;
    }

    printf("deinitialize at level %d\n", p_level);
}

GDExtensionBool hello_extension_entry(
    const GDExtensionInterface *p_interface,
    GDExtensionClassLibraryPtr p_library,
    GDExtensionInitialization *r_initialization
) {
    r_initialization->initialize = &initialize;
    r_initialization->deinitialize = &deinitialize;
    return 1;
}
```

Recompile and re-run Godot to see that only initialization level 2 ("Scene") is being processed:

```sh
godot --upwards --headless --quit
# Godot Engine v4.0.beta10.official.d0398f62f - https://godotengine.org
# 
# initialize at level 2
# deinitialize at level 2
```

All right, our library is now being initialized without crashes!


## Using Godot utility functions
TODO
